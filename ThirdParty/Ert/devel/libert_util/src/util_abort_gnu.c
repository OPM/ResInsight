/*
  This file implements the fully fledged util abort() function which
  assumes that the current build has the following features:

    fork()     : To support calling external program addr2line().
    pthread    : To serialize the use of util abort() - not very important.
    execinfo.h : The backtrace functions backtrace() and backtrace symbols().

  If not all these features are availbale the simpler version in
  util abort_simple.c is built instead.
*/



/**
  This function uses the external program addr2line to convert the
  hexadecimal adress given by the libc function backtrace() into a
  function name and file:line.

  Observe that the function is quite involved, so if util_abort() is
  called because something is seriously broken, it might very well fail.

  The executable should be found from one line in the backtrace with
  the function util_bt_alloc_current_executable(), the argument
  bt_symbol is the lines generated by the  bt_symbols() function.

  This function is purely a helper function for util_abort().
*/

static void util_addr2line_lookup(const char * executable , const char * bt_symbol , char ** func_name , char ** file_line) {
  char *tmp_file = util_alloc_tmp_file("/tmp" , "addr2line" , true);
  char * adress;
  {
    int start_pos = 0;
    int end_pos;   
    while ( bt_symbol[start_pos] != '[')
      start_pos++;
    
      end_pos = start_pos;
      while ( bt_symbol[end_pos] != ']') 
        end_pos++;
      
      adress = util_alloc_substring_copy( bt_symbol , start_pos + 1 , end_pos - start_pos - 1 );
  }
  
  {
    char ** argv;
    
    argv    = util_calloc(3 , sizeof * argv );
    argv[0] = util_alloc_string_copy("--functions");
    argv[1] = util_alloc_sprintf("--exe=%s" , executable);
    argv[2] = util_alloc_string_copy(adress);
    
    util_fork_exec("addr2line" , 3  , (const char **) argv , true , NULL , NULL , NULL , tmp_file , NULL);
    util_free_stringlist(argv , 3);
  }
  
  {
    bool at_eof;
    FILE * stream = util_fopen(tmp_file , "r");
    *func_name = util_fscanf_alloc_line(stream , &at_eof);
    *file_line = util_fscanf_alloc_line(stream , &at_eof);
    fclose(stream);
  }
  util_unlink_existing(tmp_file);
  free(adress);
  free(tmp_file);
}



/**
  This function prints a message to stderr and aborts. The function is
  implemented with the help of a variable length argument list - just
  like printf(fmt , arg1, arg2 , arg3 ...);

  Observe that it is __VERY__ important that the arguments and the
  format string match up, otherwise the util_abort() routine will hang
  indefinetely; without printing anything to stderr.

  A backtrace is also included, with the help of the exernal utility
  addr2line, this backtrace is converted into usable
  function/file/line information (provided the required debugging
  information is compiled in).
*/

static pthread_mutex_t __abort_mutex  = PTHREAD_MUTEX_INITIALIZER; /* Used purely to serialize the util_abort() routine. */

/**
   If the variable __current_executable has been set, that value is
   returned as the executable, otherwise an attempt (which generally
   works) is made to try to extract it from the output from
   bt_symbols().
   
   This function takes one string from the string list generated by
   bt_symbols(). From this string it extracts the full path to the
   current executable. This path is needed for subsequent calls to
   util_addr2line_lookup().
   
   This function is purely a helper function for util_abort().
*/

static char * util_bt_alloc_current_executable(const char * bt_symbol) {
  if (__current_executable != NULL) 
    return util_alloc_string_copy(__current_executable );
  else {
    if (bt_symbol != NULL) {
      int paren_pos = 0;
      char * path;
      while (bt_symbol[paren_pos] != '(' && bt_symbol[paren_pos] != ' ')
        paren_pos++;
      
      path = util_alloc_substring_copy(bt_symbol , 0 , paren_pos);
      if (util_is_abs_path(path))
        return path;
      else {
        char * full_path = util_alloc_PATH_executable( path );
        free(path);
        return full_path;
      }
    } else 
      return NULL;
  }
}


void util_abort(const char * fmt , ...) {
  pthread_mutex_lock( &__abort_mutex ); /* Abort before unlock() */
  {
    va_list ap;

    va_start(ap , fmt);
    printf("\n\n");
    fprintf(stderr,"\n\n");
    vfprintf(stderr , fmt , ap);
    va_end(ap);

    /*
      The backtrace is based on calling the external program
      addr2line; the call is based on util_fork_exec() which is
      currently only available on POSIX.
    */

    const bool include_backtrace = true;
    if (include_backtrace) {
      const int max_bt = 50;
      char *executable;
      void *array[max_bt];
      char **strings;
      char ** func_list;
      char ** file_line_list;
      int    max_func_length = 0;
      int    size,i;
  
      if (__abort_program_message != NULL) {
        fprintf(stderr,"--------------------------------------------------------------------------------\n");
        fprintf(stderr,"%s",__abort_program_message);
        fprintf(stderr,"--------------------------------------------------------------------------------\n");
      }

      fprintf(stderr,"\n");
      fprintf(stderr,"****************************************************************************\n");
      fprintf(stderr,"**                                                                        **\n");
      fprintf(stderr,"**           A fatal error occured, and we have to abort.                 **\n");
      fprintf(stderr,"**                                                                        **\n");
      fprintf(stderr,"**  We now *try* to provide a backtrace, which would be very useful       **\n");
      fprintf(stderr,"**  when debugging. The process of making a (human readable) backtrace    **\n");
      fprintf(stderr,"**  is quite complex, among other things it involves several calls to the **\n");
      fprintf(stderr,"**  external program addr2line. We have arrived here because the program  **\n");
      fprintf(stderr,"**  state is already quite broken, so the backtrace might be (seriously)  **\n");
      fprintf(stderr,"**  broken as well.                                                       **\n");
      fprintf(stderr,"**                                                                        **\n");
      fprintf(stderr,"****************************************************************************\n");
      size       = backtrace(array , max_bt);
      strings    = backtrace_symbols(array , size);    
      executable = util_bt_alloc_current_executable(strings[0]);
      if (executable != NULL) {
        fprintf(stderr,"Current executable : %s \n",executable);
        
        func_list      = util_calloc(size , sizeof * func_list      );
        file_line_list = util_calloc(size , sizeof * file_line_list );
        
        for (i=0; i < size; i++) {
          util_addr2line_lookup(executable , strings[i] , &func_list[i] , &file_line_list[i]);
          max_func_length = util_int_max(max_func_length , strlen(func_list[i]));
        }
        
        {
          char string_fmt[64];
          sprintf(string_fmt, " #%s02d %s-%ds(..) in %ss   \n" , "%" , "%" , max_func_length , "%");
          fprintf(stderr , "--------------------------------------------------------------------------------\n");
          for (i=0; i < size; i++) {
            
            int line_nr;
            if (util_sscanf_int(file_line_list[i] , &line_nr))
              fprintf(stderr, string_fmt , i , func_list[i], file_line_list[i]);
            else
              fprintf(stderr, string_fmt , i , func_list[i], file_line_list[i]);
          }
          fprintf(stderr , "--------------------------------------------------------------------------------\n");
          util_free_stringlist(func_list      , size);
          util_free_stringlist(file_line_list , size);
        }
      } else
        fprintf(stderr,"Could not determine executable file for:%s - no backtrace. \n",strings[0]);
      
      free(strings);
      util_safe_free(executable);
    }

    if (getenv("UTIL_ABORT") != NULL) {
      fprintf(stderr , "Aborting ... \n");
      abort();
    } else {
      fprintf(stderr , "Exiting ... \n");
      exit(1);
    }
    // Would have preferred abort() here - but that comes in conflict with the SIGABRT signal.
  }
  pthread_mutex_unlock( &__abort_mutex );
}

