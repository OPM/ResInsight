/////////////////////////////////////////////////////////////////////////////////
//
//  Copyright (C) 2023-     Equinor ASA
//
//  ResInsight is free software: you can redistribute it and/or modify
//  it under the terms of the GNU General Public License as published by
//  the Free Software Foundation, either version 3 of the License, or
//  (at your option) any later version.
//
//  ResInsight is distributed in the hope that it will be useful, but WITHOUT ANY
//  WARRANTY; without even the implied warranty of MERCHANTABILITY or
//  FITNESS FOR A PARTICULAR PURPOSE.
//
//  See the GNU General Public License at <http://www.gnu.org/licenses/gpl.html>
//  for more details.
//
/////////////////////////////////////////////////////////////////////////////////

#include "RifFaultReactivationModelExporter.h"
#include "RigFaultReactivationModel.h"
#include "RigGriddedPart3d.h"

#include "RiaApplication.h"
#include "RiaVersionInfo.h"

#include "RifInpExportTools.h"

#include <fstream>

//--------------------------------------------------------------------------------------------------
///
//--------------------------------------------------------------------------------------------------
std::pair<bool, std::string> RifFaultReactivationModelExporter::exportToStream( std::ostream& stream, const RigFaultReactivationModel& model )
{
    RifInpExportTools::printHeading( stream, "Heading" );
    RifInpExportTools::printComment( stream, std::string( "Generated by: " ).append( STRPRODUCTVER ) );

    RifInpExportTools::printHeading( stream, "Preprint, echo=NO, model=NO, history=NO, contact=NO" );

    RifInpExportTools::printComment( stream, "PARTS" );

    auto parts = model.allGridParts();

    int partIndex = 1;
    for ( auto part : parts )
    {
        std::string partName = "Part-" + std::to_string( partIndex );
        RifInpExportTools::printHeading( stream, "Part, name=" + partName );

        auto grid = model.grid( part );

        const std::vector<cvf::Vec3d>& nodes = grid->vertices();
        RifInpExportTools::printNodes( stream, nodes );

        const std::vector<std::vector<unsigned int>>& elements = grid->elementIndices();
        RifInpExportTools::printElements( stream, elements );

        RifInpExportTools::printNodeSet( stream, partName, 1, nodes.size() );
        RifInpExportTools::printElementSet( stream, partName, 1, elements.size() );

        std::vector<std::pair<RigGriddedPart3d::BorderSurface, std::string>> borders =
            { { RigGriddedPart3d::BorderSurface::UpperSurface, "top" },
              { RigGriddedPart3d::BorderSurface::FaultSurface, "fault" },
              { RigGriddedPart3d::BorderSurface::LowerSurface, "base" } };

        const std::map<RigGriddedPart3d::BorderSurface, std::vector<unsigned int>>& borderSurfaceElements = grid->borderSurfaceElements();

        for ( auto [border, borderName] : borders )
        {
            int elementSide = 4;

            std::string sideName        = "S" + std::to_string( elementSide );
            auto        surfaceElements = borderSurfaceElements.find( border );
            if ( surfaceElements != borderSurfaceElements.end() )
            {
                std::string borderElementName = "_" + borderName + "_" + sideName;
                RifInpExportTools::printElementSet( stream, borderElementName, surfaceElements->second );
                RifInpExportTools::printSurface( stream, borderName, borderElementName, sideName );
            }
        }

        RifInpExportTools::printComment( stream, "Section: sand" );
        RifInpExportTools::printHeading( stream, "Solid Section, elset=" + partName + ", material=sand" );

        RifInpExportTools::printLine( stream, "," );
        RifInpExportTools::printHeading( stream, "End Part" );

        partIndex++;
    }

    RifInpExportTools::printHeading( stream, "Assembly, name=Assembly" );

    // ASSEMBLY part
    partIndex = 1;
    for ( auto part : parts )
    {
        std::string partName     = "Part-" + std::to_string( partIndex );
        std::string instanceName = partName + "-1";
        RifInpExportTools::printHeading( stream, "Instance, name=" + instanceName + ", part=" + partName );

        std::string nodeSetName = "part_" + std::to_string( partIndex ) + "_PP_";
        auto        grid        = model.grid( part );

        const std::vector<cvf::Vec3d>& nodes = grid->vertices();
        RifInpExportTools::printNodeSet( stream, partName, 1, nodes.size() );

        RifInpExportTools::printHeading( stream, "End Instance" );

        // TODO: print boundary condition sets here
    }

    // MATERIALS PART
    struct Material
    {
        std::string name;
        double      density;
        double      elastic1;
        double      elastic2;
        double      permeability1;
        double      permeability2;
    };

    RifInpExportTools::printComment( stream, "MATERIALS" );

    std::vector<Material> materials = {
        Material{ .name = "sand", .density = 2000.0, .elastic1 = 5e+09, .elastic2 = 0.2, .permeability1 = 1e-09, .permeability2 = 0.3 } };
    for ( Material mat : materials )
    {
        RifInpExportTools::printHeading( stream, "Material, name=" + mat.name );
        RifInpExportTools::printHeading( stream, "Density" );
        RifInpExportTools::printNumber( stream, mat.density );
        RifInpExportTools::printHeading( stream, "Elastic" );
        RifInpExportTools::printNumbers( stream, { mat.elastic1, mat.elastic2 } );

        RifInpExportTools::printHeading( stream, "Permeability, specific=1." );
        RifInpExportTools::printNumbers( stream, { mat.permeability1, mat.permeability2 } );
    }

    return { false, "" };
}

//--------------------------------------------------------------------------------------------------
///
//--------------------------------------------------------------------------------------------------
std::pair<bool, std::string> RifFaultReactivationModelExporter::exportToFile( const std::string&               filePath,
                                                                              const RigFaultReactivationModel& model )
{
    std::ofstream stream( filePath );
    return exportToStream( stream, model );
}
