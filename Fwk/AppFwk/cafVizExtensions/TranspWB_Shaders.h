// clang-format off


// -----------------------------------------
// THIS IS A GENERATED FILE!!  DO NOT MODIFY
// -----------------------------------------

//#############################################################################################################################
//#############################################################################################################################
static const char TranspWB_CombinationFrag_inl[] =
"//--------------------------------------------------------------------------------------                                                  \n"
"// Weighted Blended Order-Independent Transparency                                                                                        \n"
"// Morgan McGuire and Louis Bavoil NVIDIA                                                                                                 \n"
"// Journal of Computer Graphics Techniques Vol. 2, No. 2, 2013                                                                            \n"
"// Adapted by Jacob Støren to fit with a pure combination pass with no blending                                                           \n"
"//--------------------------------------------------------------------------------------                                                  \n"
"                                                                                                                                          \n"
"#extension GL_ARB_texture_rectangle : enable                                                                                              \n"
"                                                                                                                                          \n"
"uniform sampler2DRect sumWeightedRgbAndProductOneMinusAlphaTexture;                                                                       \n"
"uniform sampler2DRect sumWeightedAlphaTexture;                                                                                            \n"
"uniform sampler2DRect opaceColorTexture;                                                                                                  \n"
"                                                                                                                                          \n"
"void main(void)                                                                                                                           \n"
"{                                                                                                                                         \n"
"    // Reference codeFrom the paper. Not correct because we do no blending in the last pass                                               \n"
"    // gl_FragColor = vec4(sumWeightedColor/clamp(sumWeightedAlpha, 1e-4, 5e4), productOneMinusAlpha);                                    \n"
"                                                                                                                                          \n"
"    // Get the different components from the textures                                                                                     \n"
"    vec3  sumWeightedColor = texture2DRect(sumWeightedRgbAndProductOneMinusAlphaTexture, gl_FragCoord.xy).rgb;                            \n"
"    float sumWeightedAlpha = texture2DRect(sumWeightedAlphaTexture, gl_FragCoord.xy).r;                                                   \n"
"    float productOneMinusAlpha = texture2DRect(sumWeightedRgbAndProductOneMinusAlphaTexture, gl_FragCoord.xy).a;                          \n"
"                                                                                                                                          \n"
"    vec4 opaceColor = texture2DRect(opaceColorTexture, gl_FragCoord.xy);                                                                  \n"
"                                                                                                                                          \n"
"    //vec3 sumWColorPrSumWAlpha = sumWeightedColor/sumWeightedAlpha;                                                                      \n"
"    vec3 sumWColorPrSumWAlpha = sumWeightedColor/clamp(sumWeightedAlpha, 1.0e-7, 5.0e3 );                                                 \n"
"                                                                                                                                          \n"
"                                                                                                                                          \n"
"    // Helpers to visualize different parts of the equation                                                                               \n"
"    vec4 resultColor;                                                                                                                     \n"
"                                                                                                                                          \n"
"    //resultColor = opaceColor;                                                                                                           \n"
"    //resultColor = opaceColor * productOneMinusAlpha;                                                                                    \n"
"    //resultColor = vec4(productOneMinusAlpha * opaceColor.rgb, 1.0);                                                                     \n"
"    //resultColor = vec4( sumWColorPrSumWAlpha, 1.0);                                                                                     \n"
"    //resultColor = vec4(sumWColorPrSumWAlpha  + productOneMinusAlpha * opaceColor.rgb, 1.0);                                             \n"
"    //resultColor = vec4(productOneMinusAlpha* sumWColorPrSumWAlpha, 1.0);                                                                \n"
"                                                                                                                                          \n"
"    // The final correct equation                                                                                                         \n"
"    resultColor = vec4(sumWColorPrSumWAlpha - productOneMinusAlpha * sumWColorPrSumWAlpha + productOneMinusAlpha * opaceColor.rgb, 1.0);  \n"
"                                                                                                                                          \n"
"    gl_FragColor =  resultColor;                                                                                                          \n"
"}                                                                                                                                         \n";



//#############################################################################################################################
//#############################################################################################################################
static const char TranspWB_PartlyTranspPartsFrag_inl[] =
"//--------------------------------------------------------------------------------------  \n"
"// Weighted Blended Order-Independent Transparency                                        \n"
"// Morgan McGuire and Louis Bavoil NVIDIA                                                 \n"
"// Journal of Computer Graphics Techniques Vol. 2, No. 2, 2013                            \n"
"                                                                                          \n"
"//--------------------------------------------------------------------------------------  \n"
"                                                                                          \n"
"#extension GL_ARB_draw_buffers : require                                                  \n"
"                                                                                          \n"
"vec4 srcFragment();                                                                       \n"
"vec4 lightFragment(vec4 srcFragColor, float shadowFactor);                                \n"
"                                                                                          \n"
"uniform int isOpaquePass;                                                                 \n"
"                                                                                          \n"
"float depthWeight(float depth, float alpha)                                               \n"
"{                                                                                         \n"
"    //return 1.0; // For testing                                                          \n"
"    return alpha * max(1e-2, 3e3 * pow((1 - gl_FragCoord.z), 3));  // Proposed by paper   \n"
"    //return alpha * max(1e-1, 3e4 * pow((1 - gl_FragCoord.z), 4));  // JJS               \n"
"}                                                                                         \n"
"                                                                                          \n"
"void main(void)                                                                           \n"
"{                                                                                         \n"
"    vec4 color = srcFragment();                                                           \n"
"    color = lightFragment(color, 1.0);                                                    \n"
"    if (isOpaquePass == 1)                                                                \n"
"    {                                                                                     \n"
"        if (color.a < 1.0)                                                                \n"
"        {                                                                                 \n"
"            discard;                                                                      \n"
"        }                                                                                 \n"
"        else                                                                              \n"
"        {                                                                                 \n"
"            gl_FragData[0] = color;                                                       \n"
"        }                                                                                 \n"
"    }                                                                                     \n"
"    else                                                                                  \n"
"    {                                                                                     \n"
"        if (color.a == 1.0)                                                               \n"
"        {                                                                                 \n"
"            discard;                                                                      \n"
"        }                                                                                 \n"
"        else                                                                              \n"
"        {                                                                                 \n"
"            vec3 preMultipliedRgb = color.a*color.rgb;                                    \n"
"                                                                                          \n"
"            gl_FragData[0] = vec4(preMultipliedRgb * depthWeight(0, color.a), color.a);   \n"
"            gl_FragData[1].r = color.a * depthWeight(0, color.a);                         \n"
"        }                                                                                 \n"
"    }                                                                                     \n"
"}                                                                                         \n";



//#############################################################################################################################
//#############################################################################################################################
static const char TranspWB_TransparentPartsFrag_inl[] =
"//--------------------------------------------------------------------------------------                            \n"
"// Weighted Blended Order-Independent Transparency                                                                  \n"
"// Morgan McGuire and Louis Bavoil NVIDIA                                                                           \n"
"// Journal of Computer Graphics Techniques Vol. 2, No. 2, 2013                                                      \n"
"                                                                                                                    \n"
"//--------------------------------------------------------------------------------------                            \n"
"                                                                                                                    \n"
"#extension GL_ARB_draw_buffers : require                                                                            \n"
"                                                                                                                    \n"
"vec4 srcFragment();                                                                                                 \n"
"vec4 lightFragment(vec4 srcFragColor, float shadowFactor);                                                          \n"
"                                                                                                                    \n"
"uniform float cameraNear;                                                                                           \n"
"uniform float cameraFar;                                                                                            \n"
"                                                                                                                    \n"
"float realZDepth(float fragCoordZ) {                                                                                \n"
"                                                                                                                    \n"
"    return (cameraFar * cameraNear) / (cameraFar - fragCoordZ * (cameraFar - cameraNear)) ;                         \n"
"}                                                                                                                   \n"
"                                                                                                                    \n"
"float depthWeight(float fragCoordZ, float alpha)                                                                    \n"
"{                                                                                                                   \n"
"    //return 1.0; // For testing                                                                                    \n"
"    //return alpha * max(1e-2, 3e3 * pow((1 - fragCoordZ), 3));  // Proposed by paper                               \n"
"                                                                                                                    \n"
"    float zDepth = realZDepth(fragCoordZ);                                                                          \n"
"    return alpha * max(1e-2, min(3e3, 10 / (1e5 + pow(zDepth/10, 3) + pow(zDepth/200, 6) ))); // Proposed by paper  \n"
"    //return zDepth;                                                                                                \n"
"}                                                                                                                   \n"
"                                                                                                                    \n"
"void main(void)                                                                                                     \n"
"{                                                                                                                   \n"
"    vec4 color = srcFragment();                                                                                     \n"
"    color = lightFragment(color, 1.0);                                                                              \n"
"                                                                                                                    \n"
"    vec3 preMultipliedRgb = color.a*color.rgb;                                                                      \n"
"                                                                                                                    \n"
"    gl_FragData[0] = vec4(preMultipliedRgb * depthWeight(gl_FragCoord.z, color.a), color.a);                        \n"
"    gl_FragData[1].r = color.a * depthWeight(gl_FragCoord.z, color.a);                                              \n"
"}                                                                                                                   \n";

// clang-format on
